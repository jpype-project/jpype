This is a set of experimental changes to fix the issues with Java 8 lambdas.

The current jpype system is using names to distinguish classes, but lambdas
don't have names that the class loader can find.  Thus any lambda chokes the 
system badly.  We tried to switch this to jclass but these are handles that
are not unique.  Comparing them with java doesn't work because it is both
slow and won't work in a map.  We tried hashcodes but those aren't unique
either.  Thus there is no good solution down the current path.  And the
things are likely to just get worse by Java 9.

The following proposal is to do the opposite. Rather than forcing C++
to understand java types, we instead move all of the support for type
management to Java.  Java will create C++ types through the JNI interface
as it needs them and control the lifespan.  Further the typemanager will
be synchronized with locks so that threading can never be cause an issue.

This will remove the majority of the jp_jniutil.cpp functions as java
will simply pass everything that is needed at the native layer.  There will
be no need for C++ to talk to JNI except to convert types or communicate with
the TypeManager.  The TypeManager can be communicated with directly through
python using the org.jpype.TypeManager object.  Thus we can do much 
easier probing of the state of the system without having to add more 
stuff to the python module.  Thus we will slim both the python _jpype 
module and the C++ support classes.  Further, as we can test aspects
of the system in java natively we can increase the speed of development
cycles.

There are some downsides.  The thunks are likely to grow pretty large.  We
may want to come up with a better way to encode the thunks in the _jpype
binary.  Perhaps we can construct a jar and use a custom class loader to
fetch the jar out to binary.  Also maintaining the JNI interface may be
less than fun, but perhaps a utility function can use reflection to 
write stubs for the process.


